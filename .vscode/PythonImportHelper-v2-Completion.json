[
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "DES3",
        "importPath": "Cryptodome.Cipher",
        "description": "Cryptodome.Cipher",
        "isExtraImport": true,
        "detail": "Cryptodome.Cipher",
        "documentation": {}
    },
    {
        "label": "get_random_bytes",
        "importPath": "Cryptodome.Random",
        "description": "Cryptodome.Random",
        "isExtraImport": true,
        "detail": "Cryptodome.Random",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "ARC4",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "RSA",
        "importPath": "Crypto.PublicKey",
        "description": "Crypto.PublicKey",
        "isExtraImport": true,
        "detail": "Crypto.PublicKey",
        "documentation": {}
    },
    {
        "label": "Crypto.Util.number",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "Crypto.Util.number",
        "description": "Crypto.Util.number",
        "detail": "Crypto.Util.number",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "calculate_entropy",
        "kind": 2,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "def calculate_entropy(text):\n    # Подсчет частоты появления каждого символа\n    char_freq = {}\n    total_chars = len(text)\n    for char in text:\n        if char.isalpha():\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "calculate_entropy_graph",
        "kind": 2,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "def calculate_entropy_graph(text):\n    # Подсчет частоты появления каждого символа\n    char_freq = {}\n    total_chars = len(text)\n    for char in text:\n        if char.isalpha():\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "calculate_binary_entropy",
        "kind": 2,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "def calculate_binary_entropy(text):\n    # Подсчет частоты появления каждого символа\n    char_freq = {}\n    total_chars = len(text)\n    for char in text:\n        if char.isdigit():\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "calculate_binary_entropy_graph",
        "kind": 2,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "def calculate_binary_entropy_graph(text):\n    # Подсчет частоты появления каждого символа\n    char_freq = {}\n    total_chars = len(text)\n    for char in text:\n        if char.isdigit():\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "is_binary",
        "kind": 2,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "def is_binary(text):\n    for char in text:\n        if char not in ['0', '1']:\n            return False\n    return True\ndef effective_entropy(text, p):\n    q = 1 - p\n    if is_binary(text) and (p == 0 or q == 0):\n        return 1\n    elif  q==0:",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "effective_entropy",
        "kind": 2,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "def effective_entropy(text, p):\n    q = 1 - p\n    if is_binary(text) and (p == 0 or q == 0):\n        return 1\n    elif  q==0:\n        return 1\n    elif is_binary(text):\n        return calculate_binary_entropy(text) - (- p * math.log2(p) - q * math.log2(q))\n    else:\n     return calculate_entropy(text) - (- p * math.log2(p) - q * math.log2(q))",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "info_amount_with_errors",
        "kind": 2,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "def info_amount_with_errors(file, p):\n    try:\n        with open(file, 'r') as f:\n            text = f.read()\n        return effective_entropy(text, p) * len(text)\n    except FileNotFoundError:\n        return None\nerror_probabilities = [0.1, 0.5, 1.0]\n# Обработка текста на латинице\nwith open(\"latin_text.txt\", \"r\", encoding=\"utf-8\") as file:",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "error_probabilities",
        "kind": 5,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "error_probabilities = [0.1, 0.5, 1.0]\n# Обработка текста на латинице\nwith open(\"latin_text.txt\", \"r\", encoding=\"utf-8\") as file:\n    latin_text = file.read()\nprint(\"Для текста на латинице:\")\nlat_ent = calculate_entropy_graph(latin_text)\n# Обработка текста на русском\nwith open(\"cyrilic_text.txt\", \"r\", encoding=\"utf-8\") as file:\n    cyrillic_text = file.read()\nprint(\"\\nДля текста на русском:\")",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "lat_ent",
        "kind": 5,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "lat_ent = calculate_entropy_graph(latin_text)\n# Обработка текста на русском\nwith open(\"cyrilic_text.txt\", \"r\", encoding=\"utf-8\") as file:\n    cyrillic_text = file.read()\nprint(\"\\nДля текста на русском:\")\ncyr_entr = calculate_entropy_graph(cyrillic_text)\n# обработка текста в бинарном виде\nwith open(\"binary_latin_text.txt\", \"r\", encoding=\"utf-8\") as file:\n    binary_latin = file.read()\nprint(\"Для текста на латинице в бинарном виде:\")",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "cyr_entr",
        "kind": 5,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "cyr_entr = calculate_entropy_graph(cyrillic_text)\n# обработка текста в бинарном виде\nwith open(\"binary_latin_text.txt\", \"r\", encoding=\"utf-8\") as file:\n    binary_latin = file.read()\nprint(\"Для текста на латинице в бинарном виде:\")\nbin_lat_ent = calculate_binary_entropy_graph(binary_latin)\nfor error_probability in error_probabilities:\n    print(f\"Количество информации в бинарном файле (p={error_probability}): {abs( info_amount_with_errors('./binary_latin_text.txt', error_probability))}\")\n    print(f\"Количество информации в файле ASCII (p={error_probability}): {info_amount_with_errors('./latin_text.txt', error_probability)}\\n\")\nlength_cyr = len('Макаров Алексей Игоревич')",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "bin_lat_ent",
        "kind": 5,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "bin_lat_ent = calculate_binary_entropy_graph(binary_latin)\nfor error_probability in error_probabilities:\n    print(f\"Количество информации в бинарном файле (p={error_probability}): {abs( info_amount_with_errors('./binary_latin_text.txt', error_probability))}\")\n    print(f\"Количество информации в файле ASCII (p={error_probability}): {info_amount_with_errors('./latin_text.txt', error_probability)}\\n\")\nlength_cyr = len('Макаров Алексей Игоревич')\nlength_lat = len('Makarau Aliaksei Iharavich')\nprint('Количество информации в ФИО на кирилице:', length_cyr * cyr_entr)\nprint('Количество информации в ФИО на латинице:', length_lat * lat_ent)",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "length_cyr",
        "kind": 5,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "length_cyr = len('Макаров Алексей Игоревич')\nlength_lat = len('Makarau Aliaksei Iharavich')\nprint('Количество информации в ФИО на кирилице:', length_cyr * cyr_entr)\nprint('Количество информации в ФИО на латинице:', length_lat * lat_ent)",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "length_lat",
        "kind": 5,
        "importPath": "lab1.lab1",
        "description": "lab1.lab1",
        "peekOfCode": "length_lat = len('Makarau Aliaksei Iharavich')\nprint('Количество информации в ФИО на кирилице:', length_cyr * cyr_entr)\nprint('Количество информации в ФИО на латинице:', length_lat * lat_ent)",
        "detail": "lab1.lab1",
        "documentation": {}
    },
    {
        "label": "custom_xor_base64",
        "kind": 2,
        "importPath": "lab2.example",
        "description": "lab2.example",
        "peekOfCode": "def custom_xor_base64(buffer_a, buffer_b):\n    decoded_a = base64.b64decode(buffer_a)\n    decoded_b = base64.b64decode(buffer_b)\n    result = []\n    min_length = min(len(decoded_a), len(decoded_b))\n    for i in range(min_length):\n        result.append(chr(decoded_a[i] ^ decoded_b[i]))\n    return \"\".join(result)\n# Example usage\npart_1 = \"Makarov \"",
        "detail": "lab2.example",
        "documentation": {}
    },
    {
        "label": "part_1",
        "kind": 5,
        "importPath": "lab2.example",
        "description": "lab2.example",
        "peekOfCode": "part_1 = \"Makarov \"\nencoded_part_1 = base64.b64encode(part_1.encode()).decode()\nprint(encoded_part_1)\npart_2 = \"Alexey\"\nencoded_part_2 = base64.b64encode(part_2.encode()).decode()\nprint(encoded_part_2)\nresult = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(result)",
        "detail": "lab2.example",
        "documentation": {}
    },
    {
        "label": "encoded_part_1",
        "kind": 5,
        "importPath": "lab2.example",
        "description": "lab2.example",
        "peekOfCode": "encoded_part_1 = base64.b64encode(part_1.encode()).decode()\nprint(encoded_part_1)\npart_2 = \"Alexey\"\nencoded_part_2 = base64.b64encode(part_2.encode()).decode()\nprint(encoded_part_2)\nresult = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(result)",
        "detail": "lab2.example",
        "documentation": {}
    },
    {
        "label": "part_2",
        "kind": 5,
        "importPath": "lab2.example",
        "description": "lab2.example",
        "peekOfCode": "part_2 = \"Alexey\"\nencoded_part_2 = base64.b64encode(part_2.encode()).decode()\nprint(encoded_part_2)\nresult = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(result)",
        "detail": "lab2.example",
        "documentation": {}
    },
    {
        "label": "encoded_part_2",
        "kind": 5,
        "importPath": "lab2.example",
        "description": "lab2.example",
        "peekOfCode": "encoded_part_2 = base64.b64encode(part_2.encode()).decode()\nprint(encoded_part_2)\nresult = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(result)",
        "detail": "lab2.example",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "lab2.example",
        "description": "lab2.example",
        "peekOfCode": "result = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(result)",
        "detail": "lab2.example",
        "documentation": {}
    },
    {
        "label": "calculate_entropy",
        "kind": 2,
        "importPath": "lab2.lab1",
        "description": "lab2.lab1",
        "peekOfCode": "def calculate_entropy(text):\n    # Подсчет частоты появления каждого символа\n    char_freq = {}\n    total_chars = len(text)\n    for char in text:\n        if char.isalpha():\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1",
        "detail": "lab2.lab1",
        "documentation": {}
    },
    {
        "label": "calculate_entropy_graph",
        "kind": 2,
        "importPath": "lab2.lab1",
        "description": "lab2.lab1",
        "peekOfCode": "def calculate_entropy_graph(text):\n    # Подсчет частоты появления каждого символа\n    char_freq = {}\n    total_chars = len(text)\n    for char in text:\n        if char.isalpha():\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1",
        "detail": "lab2.lab1",
        "documentation": {}
    },
    {
        "label": "is_binary",
        "kind": 2,
        "importPath": "lab2.lab1",
        "description": "lab2.lab1",
        "peekOfCode": "def is_binary(text):\n    for char in text:\n        if char not in [\"0\", \"1\"]:\n            return False\n    return True\ndef effective_entropy(text, p):\n    q = 1 - p\n    if is_binary(text) and (p == 0 or q == 0):\n        return 1\n    elif q == 0:",
        "detail": "lab2.lab1",
        "documentation": {}
    },
    {
        "label": "effective_entropy",
        "kind": 2,
        "importPath": "lab2.lab1",
        "description": "lab2.lab1",
        "peekOfCode": "def effective_entropy(text, p):\n    q = 1 - p\n    if is_binary(text) and (p == 0 or q == 0):\n        return 1\n    elif q == 0:\n        return 1\n    else:\n        return calculate_entropy(text) - (-p * math.log2(p) - q * math.log2(q))\ndef info_amount_with_errors(file, p):\n    try:",
        "detail": "lab2.lab1",
        "documentation": {}
    },
    {
        "label": "info_amount_with_errors",
        "kind": 2,
        "importPath": "lab2.lab1",
        "description": "lab2.lab1",
        "peekOfCode": "def info_amount_with_errors(file, p):\n    try:\n        with open(file, \"r\") as f:\n            text = f.read()\n        return effective_entropy(text, p) * len(text)\n    except FileNotFoundError:\n        return None\nerror_probabilities = [0.1, 0.5, 1.0]\n# Обработка текста на латинице\nwith open(\"latin_text.txt\", \"r\", encoding=\"utf-8\") as file:",
        "detail": "lab2.lab1",
        "documentation": {}
    },
    {
        "label": "error_probabilities",
        "kind": 5,
        "importPath": "lab2.lab1",
        "description": "lab2.lab1",
        "peekOfCode": "error_probabilities = [0.1, 0.5, 1.0]\n# Обработка текста на латинице\nwith open(\"latin_text.txt\", \"r\", encoding=\"utf-8\") as file:\n    latin_text = file.read()\nprint(\"Для текста на латинице:\")\nlat_ent = calculate_entropy_graph(latin_text)\n# Обработка текста на русском\nwith open(\"base64_res.txt\", \"r\", encoding=\"utf-8\") as file:\n    cyrillic_text = file.read()\nprint(\"\\nДля текста base64:\")",
        "detail": "lab2.lab1",
        "documentation": {}
    },
    {
        "label": "lat_ent",
        "kind": 5,
        "importPath": "lab2.lab1",
        "description": "lab2.lab1",
        "peekOfCode": "lat_ent = calculate_entropy_graph(latin_text)\n# Обработка текста на русском\nwith open(\"base64_res.txt\", \"r\", encoding=\"utf-8\") as file:\n    cyrillic_text = file.read()\nprint(\"\\nДля текста base64:\")\ncyr_entr = calculate_entropy_graph(cyrillic_text)",
        "detail": "lab2.lab1",
        "documentation": {}
    },
    {
        "label": "cyr_entr",
        "kind": 5,
        "importPath": "lab2.lab1",
        "description": "lab2.lab1",
        "peekOfCode": "cyr_entr = calculate_entropy_graph(cyrillic_text)",
        "detail": "lab2.lab1",
        "documentation": {}
    },
    {
        "label": "convert_to_base64",
        "kind": 2,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "def convert_to_base64(filename):\n    with open(filename, \"rb\") as file:\n        encoded_string = base64.b64encode(file.read())\n    return encoded_string.decode()\ndef calculate_entropy(text):\n    frequencies = collections.Counter(text)\n    entropy = 0.0\n    total_length = len(text)\n    for freq in frequencies.values():\n        probability = freq / total_length",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "calculate_entropy",
        "kind": 2,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "def calculate_entropy(text):\n    frequencies = collections.Counter(text)\n    entropy = 0.0\n    total_length = len(text)\n    for freq in frequencies.values():\n        probability = freq / total_length\n        entropy -= probability * math.log2(probability)\n    return entropy\ndef calculate_redundancy(text):\n    frequencies = collections.Counter(text)",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "calculate_redundancy",
        "kind": 2,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "def calculate_redundancy(text):\n    frequencies = collections.Counter(text)\n    total_length = len(text)\n    max_entropy = math.log2(len(frequencies))\n    actual_entropy = 0.0\n    for freq in frequencies.values():\n        probability = freq / total_length\n        actual_entropy -= probability * math.log2(probability)\n    redundancy = (max_entropy - actual_entropy) / max_entropy\n    return redundancy",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "custom_xor_base64",
        "kind": 2,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "def custom_xor_base64(buffer_a, buffer_b):\n    decoded_a = base64.b64decode(buffer_a)\n    decoded_b = base64.b64decode(buffer_b)\n    result = []\n    min_length = min(len(decoded_a), len(decoded_b))\n    for i in range(min_length):\n        result.append(chr(decoded_a[i] ^ decoded_b[i]))\n    return \"\".join(result)\ndef custom_xor_ascii(string_a, string_b):\n    # Преобразование строк в коды ASCII",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "custom_xor_ascii",
        "kind": 2,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "def custom_xor_ascii(string_a, string_b):\n    # Преобразование строк в коды ASCII\n    ascii_a = [ord(char) for char in string_a]\n    ascii_b = [ord(char) for char in string_b]\n    # Выполнение операции XOR\n    result = []\n    min_length = min(len(ascii_a), len(ascii_b))\n    for i in range(min_length):\n        result.append(chr(ascii_a[i] ^ ascii_b[i]))\n    return \"\".join(result)",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "file_name",
        "kind": 5,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "file_name = \"latin_text.txt\"  # Название вашего текстового документа\nbase64_content = convert_to_base64(file_name)\nwith open(\"base64_res.txt\", \"w\") as file:\n    file.write(base64_content)\nwith open(\"latin_text.txt\", \"r\") as file:\n    text = file.read()\nprint(f\"избыточность base64: {calculate_redundancy(base64_content)}\")\nprint(f\"избыточность латинский алфавит: {calculate_redundancy(text)}\")\npart_1 = \"Makarov \"\nencoded_part_1 = base64.b64encode(part_1.encode()).decode()",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "base64_content",
        "kind": 5,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "base64_content = convert_to_base64(file_name)\nwith open(\"base64_res.txt\", \"w\") as file:\n    file.write(base64_content)\nwith open(\"latin_text.txt\", \"r\") as file:\n    text = file.read()\nprint(f\"избыточность base64: {calculate_redundancy(base64_content)}\")\nprint(f\"избыточность латинский алфавит: {calculate_redundancy(text)}\")\npart_1 = \"Makarov \"\nencoded_part_1 = base64.b64encode(part_1.encode()).decode()\nprint(f\"закодированная часть 1: {encoded_part_1}\")",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "part_1",
        "kind": 5,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "part_1 = \"Makarov \"\nencoded_part_1 = base64.b64encode(part_1.encode()).decode()\nprint(f\"закодированная часть 1: {encoded_part_1}\")\npart_2 = \"Alexey\"\nencoded_part_2 = base64.b64encode(part_2.encode()).decode()\nprint(f\"закодированная часть 2: {encoded_part_2}\")\nresult = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(f\"xor base64 {result}\")\nprint(f\"xor ascii: {custom_xor_ascii(part_1,part_2)}\")",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "encoded_part_1",
        "kind": 5,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "encoded_part_1 = base64.b64encode(part_1.encode()).decode()\nprint(f\"закодированная часть 1: {encoded_part_1}\")\npart_2 = \"Alexey\"\nencoded_part_2 = base64.b64encode(part_2.encode()).decode()\nprint(f\"закодированная часть 2: {encoded_part_2}\")\nresult = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(f\"xor base64 {result}\")\nprint(f\"xor ascii: {custom_xor_ascii(part_1,part_2)}\")",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "part_2",
        "kind": 5,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "part_2 = \"Alexey\"\nencoded_part_2 = base64.b64encode(part_2.encode()).decode()\nprint(f\"закодированная часть 2: {encoded_part_2}\")\nresult = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(f\"xor base64 {result}\")\nprint(f\"xor ascii: {custom_xor_ascii(part_1,part_2)}\")",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "encoded_part_2",
        "kind": 5,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "encoded_part_2 = base64.b64encode(part_2.encode()).decode()\nprint(f\"закодированная часть 2: {encoded_part_2}\")\nresult = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(f\"xor base64 {result}\")\nprint(f\"xor ascii: {custom_xor_ascii(part_1,part_2)}\")",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "lab2.lab2",
        "description": "lab2.lab2",
        "peekOfCode": "result = custom_xor_base64(encoded_part_1, encoded_part_2)\nprint(f\"xor base64 {result}\")\nprint(f\"xor ascii: {custom_xor_ascii(part_1,part_2)}\")",
        "detail": "lab2.lab2",
        "documentation": {}
    },
    {
        "label": "find_primes",
        "kind": 2,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "def find_primes(n):\n    primes = []\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if is_prime[i]:\n            primes.append(i)\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    for i in range(int(math.sqrt(n)) + 1, n + 1):",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "gcd",
        "kind": 2,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n# Функция для факторизации числа на простые множители\ndef prime_factors(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "prime_factors",
        "kind": 2,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "def prime_factors(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n# Функция для конкатенации чисел и проверки на простоту",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "is_concatenated_prime",
        "kind": 2,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "def is_concatenated_prime(m, n):\n    concatenated = int(str(m) + str(n))\n    if concatenated < 2:\n        return False\n    for i in range(2, int(math.sqrt(concatenated)) + 1):\n        if concatenated % i == 0:\n            return False\n    return True\n# Поиск простых чисел в интервале [m, n]\ndef find_primes_in_range(m, n):",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "find_primes_in_range",
        "kind": 2,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "def find_primes_in_range(m, n):\n    primes = []\n    for num in range(m, n + 1):\n        if all(num % i != 0 for i in range(2, int(math.sqrt(num)) + 1)):\n            primes.append(num)\n    return primes\n# Значения m и n\nm = 667\nn = 703\n# 1. Найти все простые числа в интервале [2, n]",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "m = 667\nn = 703\n# 1. Найти все простые числа в интервале [2, n]\nprimes_1 = find_primes(n)\nprint(\"Простые числа в интервале [2, n]:\", primes_1)\n# Подсчитать количество простых чисел в указанном интервале\ncount_primes_1 = len(primes_1)\nprint(\"Количество простых чисел в интервале [2, n]:\", count_primes_1)\n# Сравнить это число с n/ln(n)\nn_div_ln_n = n / math.log(n)",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "n = 703\n# 1. Найти все простые числа в интервале [2, n]\nprimes_1 = find_primes(n)\nprint(\"Простые числа в интервале [2, n]:\", primes_1)\n# Подсчитать количество простых чисел в указанном интервале\ncount_primes_1 = len(primes_1)\nprint(\"Количество простых чисел в интервале [2, n]:\", count_primes_1)\n# Сравнить это число с n/ln(n)\nn_div_ln_n = n / math.log(n)\nprint(\"n/ln(n):\", n_div_ln_n)",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "primes_1",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "primes_1 = find_primes(n)\nprint(\"Простые числа в интервале [2, n]:\", primes_1)\n# Подсчитать количество простых чисел в указанном интервале\ncount_primes_1 = len(primes_1)\nprint(\"Количество простых чисел в интервале [2, n]:\", count_primes_1)\n# Сравнить это число с n/ln(n)\nn_div_ln_n = n / math.log(n)\nprint(\"n/ln(n):\", n_div_ln_n)\nprint(\"Отношение количества простых чисел к n/ln(n):\", count_primes_1 / n_div_ln_n)\n# 2. Повторить п. 1 для интервала [m, n]",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "count_primes_1",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "count_primes_1 = len(primes_1)\nprint(\"Количество простых чисел в интервале [2, n]:\", count_primes_1)\n# Сравнить это число с n/ln(n)\nn_div_ln_n = n / math.log(n)\nprint(\"n/ln(n):\", n_div_ln_n)\nprint(\"Отношение количества простых чисел к n/ln(n):\", count_primes_1 / n_div_ln_n)\n# 2. Повторить п. 1 для интервала [m, n]\nprimes_2 = find_primes_in_range(m, n)\nprint(\"Простые числа в интервале [m, n]:\", primes_2)\n# Сравнить результаты с ручными вычислениями, используя решето Эратосфена",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "n_div_ln_n",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "n_div_ln_n = n / math.log(n)\nprint(\"n/ln(n):\", n_div_ln_n)\nprint(\"Отношение количества простых чисел к n/ln(n):\", count_primes_1 / n_div_ln_n)\n# 2. Повторить п. 1 для интервала [m, n]\nprimes_2 = find_primes_in_range(m, n)\nprint(\"Простые числа в интервале [m, n]:\", primes_2)\n# Сравнить результаты с ручными вычислениями, используя решето Эратосфена\n# Здесь просто используем количество простых чисел в интервале [2, n], так как уже реализовано решето Эратосфена\nprint(\n    \"Количество простых чисел в интервале [m, n] (с решетом Эратосфена):\", len(primes_2)",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "primes_2",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "primes_2 = find_primes_in_range(m, n)\nprint(\"Простые числа в интервале [m, n]:\", primes_2)\n# Сравнить результаты с ручными вычислениями, используя решето Эратосфена\n# Здесь просто используем количество простых чисел в интервале [2, n], так как уже реализовано решето Эратосфена\nprint(\n    \"Количество простых чисел в интервале [m, n] (с решетом Эратосфена):\", len(primes_2)\n)\n# 3. Записать числа m и n в виде произведения простых множителей\nfactors_m = prime_factors(m)\nfactors_n = prime_factors(n)",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "factors_m",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "factors_m = prime_factors(m)\nfactors_n = prime_factors(n)\nprint(\"Простые множители числа m:\", factors_m)\nprint(\"Простые множители числа n:\", factors_n)\n# 4. Проверить, является ли число, состоящее из конкатенации цифр m и n, простым\nconcatenated_prime = is_concatenated_prime(m, n)\nif concatenated_prime:\n    print(\"Число, состоящее из конкатенации цифр m и n, является простым\")\nelse:\n    print(\"Число, состоящее из конкатенации цифр m и n, не является простым\")",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "factors_n",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "factors_n = prime_factors(n)\nprint(\"Простые множители числа m:\", factors_m)\nprint(\"Простые множители числа n:\", factors_n)\n# 4. Проверить, является ли число, состоящее из конкатенации цифр m и n, простым\nconcatenated_prime = is_concatenated_prime(m, n)\nif concatenated_prime:\n    print(\"Число, состоящее из конкатенации цифр m и n, является простым\")\nelse:\n    print(\"Число, состоящее из конкатенации цифр m и n, не является простым\")\n# 5. Найти НОД (m, n)",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "concatenated_prime",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "concatenated_prime = is_concatenated_prime(m, n)\nif concatenated_prime:\n    print(\"Число, состоящее из конкатенации цифр m и n, является простым\")\nelse:\n    print(\"Число, состоящее из конкатенации цифр m и n, не является простым\")\n# 5. Найти НОД (m, n)\ngcd_m_n = gcd(m, n)\nprint(\"Наибольший общий делитель (НОД) m и n:\", gcd_m_n)\n# Выполнить задания по условиям п. 1 и 2.\nprimes_between_2_and_n = find_primes(n)",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "gcd_m_n",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "gcd_m_n = gcd(m, n)\nprint(\"Наибольший общий делитель (НОД) m и n:\", gcd_m_n)\n# Выполнить задания по условиям п. 1 и 2.\nprimes_between_2_and_n = find_primes(n)\nprimes_between_m_and_n = find_primes_in_range(m, n)\nprint(\"Простые числа в интервале [2, n]:\", primes_between_2_and_n)\nprint(\"Количество простых чисел в интервале [2, n]:\", len(primes_between_2_and_n))\nprint(\"Простые числа в интервале [m, n]:\", primes_between_m_and_n)\nprint(\"Количество простых чисел в интервале [m, n]:\", len(primes_between_m_and_n))",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "primes_between_2_and_n",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "primes_between_2_and_n = find_primes(n)\nprimes_between_m_and_n = find_primes_in_range(m, n)\nprint(\"Простые числа в интервале [2, n]:\", primes_between_2_and_n)\nprint(\"Количество простых чисел в интервале [2, n]:\", len(primes_between_2_and_n))\nprint(\"Простые числа в интервале [m, n]:\", primes_between_m_and_n)\nprint(\"Количество простых чисел в интервале [m, n]:\", len(primes_between_m_and_n))",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "primes_between_m_and_n",
        "kind": 5,
        "importPath": "lab3.lab3",
        "description": "lab3.lab3",
        "peekOfCode": "primes_between_m_and_n = find_primes_in_range(m, n)\nprint(\"Простые числа в интервале [2, n]:\", primes_between_2_and_n)\nprint(\"Количество простых чисел в интервале [2, n]:\", len(primes_between_2_and_n))\nprint(\"Простые числа в интервале [m, n]:\", primes_between_m_and_n)\nprint(\"Количество простых чисел в интервале [m, n]:\", len(primes_between_m_and_n))",
        "detail": "lab3.lab3",
        "documentation": {}
    },
    {
        "label": "snake_permutation",
        "kind": 2,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "def snake_permutation(text):\n    \"\"\"\n    Переставляет текст в змейку.\n    \"\"\"\n    rows = int(len(text) ** 0.5)\n    if rows * rows < len(text):\n        rows += 1\n    columns = rows\n    matrix = [['' for _ in range(columns)] for _ in range(rows)]\n    direction = 0 # 0 - вправо, 1 - вниз",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "encrypt_snake",
        "kind": 2,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "def encrypt_snake(text):\n    \"\"\"\n    Шифрует текст с использованием маршрутной перестановки \"змейка\".\n    \"\"\"\n    snake_text = snake_permutation(text)\n    encrypted_text = ''.join(chr((ord(char) - ord('A') + 1) % 26 + ord('A')) for char in snake_text)\n    return encrypted_text\ndef decrypt_snake(encrypted_text):\n    \"\"\"\n    Расшифровывает текст, зашифрованный с использованием маршрутной перестановки \"змейка\".",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "decrypt_snake",
        "kind": 2,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "def decrypt_snake(encrypted_text):\n    \"\"\"\n    Расшифровывает текст, зашифрованный с использованием маршрутной перестановки \"змейка\".\n    \"\"\"\n    snake_text = ''.join(chr((ord(char) - ord('A') - 1) % 26 + ord('A')) for char in encrypted_text)\n    original_text = snake_permutation(snake_text)\n    return original_text\ndef permute_text(text, keyword):\n    \"\"\"\n    Переставляет символы в тексте в соответствии с ключевым словом.",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "permute_text",
        "kind": 2,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "def permute_text(text, keyword):\n    \"\"\"\n    Переставляет символы в тексте в соответствии с ключевым словом.\n    \"\"\"\n    # Создаем словарь для хранения позиций символов в ключевом слове\n    keyword_dict = {char: index for index, char in enumerate(keyword)}\n    # Сортируем символы текста по их позициям в ключевом слове\n    sorted_text = ''.join(sorted(text, key=lambda char: keyword_dict.get(char, len(keyword))))\n    return sorted_text\ndef encrypt_with_keyword(text, keyword):",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "encrypt_with_keyword",
        "kind": 2,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "def encrypt_with_keyword(text, keyword):\n    \"\"\"\n    Шифрует текст с использованием метода множественной перестановки с ключевым словом.\n    \"\"\"\n    permuted_text = permute_text(text, keyword)\n    encrypted_text = ''.join(chr((ord(char) - ord('A') + 1) % 26 + ord('A')) for char in permuted_text)\n    return encrypted_text\ndef decrypt_with_keyword(encrypted_text, keyword):\n    \"\"\"\n    Расшифровывает текст, зашифрованный с использованием метода множественной перестановки с ключевым словом.",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "decrypt_with_keyword",
        "kind": 2,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "def decrypt_with_keyword(encrypted_text, keyword):\n    \"\"\"\n    Расшифровывает текст, зашифрованный с использованием метода множественной перестановки с ключевым словом.\n    \"\"\"\n    permuted_text = ''.join(chr((ord(char) - ord('A') - 1) % 26 + ord('A')) for char in encrypted_text)\n    original_text = permute_text(permuted_text, keyword)\n    return original_text[::-1]\ntext = \"HELLO\"\nprint(\"исходный текст: \",text)\nprint(\"змейка:\")",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 5,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "text = \"HELLO\"\nprint(\"исходный текст: \",text)\nprint(\"змейка:\")\nencrypted_text = encrypt_snake(text)\nprint(f\"Зашифрованный текст: {encrypted_text}\")\ndecrypted_text = decrypt_snake(encrypted_text)\nprint(f\"Расшифрованный текст: {decrypted_text}\")\nkeyword = \"MAKAROVALEXEY\"\nencrypted_text = encrypt_with_keyword(text, keyword)\nprint(f\"Зашифрованный текст: {encrypted_text}\")",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "encrypted_text",
        "kind": 5,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "encrypted_text = encrypt_snake(text)\nprint(f\"Зашифрованный текст: {encrypted_text}\")\ndecrypted_text = decrypt_snake(encrypted_text)\nprint(f\"Расшифрованный текст: {decrypted_text}\")\nkeyword = \"MAKAROVALEXEY\"\nencrypted_text = encrypt_with_keyword(text, keyword)\nprint(f\"Зашифрованный текст: {encrypted_text}\")\ndecrypted_text = decrypt_with_keyword(encrypted_text, keyword)\nprint(f\"Расшифрованный текст: {decrypted_text}\")",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "decrypted_text",
        "kind": 5,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "decrypted_text = decrypt_snake(encrypted_text)\nprint(f\"Расшифрованный текст: {decrypted_text}\")\nkeyword = \"MAKAROVALEXEY\"\nencrypted_text = encrypt_with_keyword(text, keyword)\nprint(f\"Зашифрованный текст: {encrypted_text}\")\ndecrypted_text = decrypt_with_keyword(encrypted_text, keyword)\nprint(f\"Расшифрованный текст: {decrypted_text}\")",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "keyword",
        "kind": 5,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "keyword = \"MAKAROVALEXEY\"\nencrypted_text = encrypt_with_keyword(text, keyword)\nprint(f\"Зашифрованный текст: {encrypted_text}\")\ndecrypted_text = decrypt_with_keyword(encrypted_text, keyword)\nprint(f\"Расшифрованный текст: {decrypted_text}\")",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "encrypted_text",
        "kind": 5,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "encrypted_text = encrypt_with_keyword(text, keyword)\nprint(f\"Зашифрованный текст: {encrypted_text}\")\ndecrypted_text = decrypt_with_keyword(encrypted_text, keyword)\nprint(f\"Расшифрованный текст: {decrypted_text}\")",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "decrypted_text",
        "kind": 5,
        "importPath": "lab5.ib_4",
        "description": "lab5.ib_4",
        "peekOfCode": "decrypted_text = decrypt_with_keyword(encrypted_text, keyword)\nprint(f\"Расшифрованный текст: {decrypted_text}\")",
        "detail": "lab5.ib_4",
        "documentation": {}
    },
    {
        "label": "rotate_rotors",
        "kind": 2,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "def rotate_rotors():\n    global rotor_positions\n    rotor_positions[0] = (rotor_positions[0] + 1) % 26\n    if rotor_positions[0] == 0:\n        rotor_positions[1] = (rotor_positions[1] + 1) % 26\n        if rotor_positions[1] == 0:\n            rotor_positions[2] = (rotor_positions[2] + 1) % 26\ndef encrypt_char(char):\n    global rotors, rotor_positions, reflector\n    char = char.upper()",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "encrypt_char",
        "kind": 2,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "def encrypt_char(char):\n    global rotors, rotor_positions, reflector\n    char = char.upper()\n    if char not in string.ascii_uppercase:\n        return char\n    # Проход через роторы\n    for i in range(3):\n        char = rotors[i][char]\n        char = chr((ord(char) - ord('A') + rotor_positions[i]) % 26 + ord('A'))\n    # Проход через рефлектор",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "encrypt_message",
        "kind": 2,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "def encrypt_message(message):\n    encrypted_message = \"\"\n    for char in message:\n        encrypted_message += encrypt_char(char)\n        rotate_rotors()\n    return encrypted_message\n# Пример использования\ndef decipher_char(char):\n    global rotors, rotor_positions, reflector\n    char = char.upper()",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "decipher_char",
        "kind": 2,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "def decipher_char(char):\n    global rotors, rotor_positions, reflector\n    char = char.upper()\n    if char not in string.ascii_uppercase:\n        return char\n    # Проход через роторы в обратном порядке\n    for i in range(2, -1, -1):\n        char = chr((ord(char) - ord('A') - rotor_positions[i]) % 26 + ord('A'))\n        char = {v: k for k, v in rotors[i].items()}[char]\n    # Проход через рефлектор",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "decipher_message",
        "kind": 2,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "def decipher_message(encrypted_message):\n    global rotors, reflector, rotor_positions\n    decrypted_message = \"\"\n    for char in encrypted_message:\n        decrypted_message += decipher_char(char)\n        rotate_rotors()\n    return decrypted_message\nmessage = \"HELLO WORLD\"\nencrypted_message = encrypt_message(message)\nprint(f\"Зашифрованное сообщение: {encrypted_message}\")",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "rotors",
        "kind": 5,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "rotors = [\n    {'A': 'E', 'B': 'K', 'C': 'M', 'D': 'F', 'E': 'L', 'F': 'G', 'G': 'D', 'H': 'Q', 'I': 'V', 'J': 'Z', 'K': 'N', 'L': 'T', 'M': 'O', 'N': 'W', 'O': 'Y', 'P': 'H', 'Q': 'X', 'R': 'U', 'S': 'S', 'T': 'P', 'U': 'A', 'V': 'I', 'W': 'B', 'X': 'R', 'Y': 'C', 'Z': 'J'},\n    {'A': 'A', 'B': 'J', 'C': 'D', 'D': 'K', 'E': 'S', 'F': 'I', 'G': 'R', 'H': 'U', 'I': 'X', 'J': 'B', 'K': 'L', 'L': 'H', 'M': 'W', 'N': 'T', 'O': 'M', 'P': 'C', 'Q': 'Q', 'R': 'G', 'S': 'Z', 'T': 'N', 'U': 'P', 'V': 'Y', 'W': 'F', 'X': 'E', 'Y': 'O', 'Z': 'V'},\n    {'A': 'B', 'B': 'D', 'C': 'F', 'D': 'G', 'E': 'H', 'F': 'I', 'G': 'J', 'H': 'K', 'I': 'L', 'J': 'M', 'K': 'N', 'L': 'O', 'M': 'P', 'N': 'Q', 'O': 'R', 'P': 'S', 'Q': 'T', 'R': 'U', 'S': 'V', 'T': 'W', 'U': 'X', 'V': 'Y', 'W': 'Z', 'X': 'A', 'Y': 'C', 'Z': 'E'}\n]\n# Начальные позиции роторов\nrotor_positions = [0, 0, 0]\n# Рефлектор\nreflector = {'A': 'Y', 'B': 'R', 'C': 'U', 'D': 'H', 'E': 'Q', 'F': 'S', 'G': 'L', 'H': 'D', 'I': 'P', 'J': 'X', 'K': 'N', 'L': 'G', 'M': 'O', 'N': 'K', 'O': 'M', 'P': 'I', 'Q': 'E', 'R': 'B', 'S': 'F', 'T': 'Z', 'U': 'C', 'V': 'W', 'W': 'V', 'X': 'J', 'Y': 'A', 'Z': 'T'}\ndef rotate_rotors():",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "rotor_positions",
        "kind": 5,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "rotor_positions = [0, 0, 0]\n# Рефлектор\nreflector = {'A': 'Y', 'B': 'R', 'C': 'U', 'D': 'H', 'E': 'Q', 'F': 'S', 'G': 'L', 'H': 'D', 'I': 'P', 'J': 'X', 'K': 'N', 'L': 'G', 'M': 'O', 'N': 'K', 'O': 'M', 'P': 'I', 'Q': 'E', 'R': 'B', 'S': 'F', 'T': 'Z', 'U': 'C', 'V': 'W', 'W': 'V', 'X': 'J', 'Y': 'A', 'Z': 'T'}\ndef rotate_rotors():\n    global rotor_positions\n    rotor_positions[0] = (rotor_positions[0] + 1) % 26\n    if rotor_positions[0] == 0:\n        rotor_positions[1] = (rotor_positions[1] + 1) % 26\n        if rotor_positions[1] == 0:\n            rotor_positions[2] = (rotor_positions[2] + 1) % 26",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "reflector",
        "kind": 5,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "reflector = {'A': 'Y', 'B': 'R', 'C': 'U', 'D': 'H', 'E': 'Q', 'F': 'S', 'G': 'L', 'H': 'D', 'I': 'P', 'J': 'X', 'K': 'N', 'L': 'G', 'M': 'O', 'N': 'K', 'O': 'M', 'P': 'I', 'Q': 'E', 'R': 'B', 'S': 'F', 'T': 'Z', 'U': 'C', 'V': 'W', 'W': 'V', 'X': 'J', 'Y': 'A', 'Z': 'T'}\ndef rotate_rotors():\n    global rotor_positions\n    rotor_positions[0] = (rotor_positions[0] + 1) % 26\n    if rotor_positions[0] == 0:\n        rotor_positions[1] = (rotor_positions[1] + 1) % 26\n        if rotor_positions[1] == 0:\n            rotor_positions[2] = (rotor_positions[2] + 1) % 26\ndef encrypt_char(char):\n    global rotors, rotor_positions, reflector",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "message",
        "kind": 5,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "message = \"HELLO WORLD\"\nencrypted_message = encrypt_message(message)\nprint(f\"Зашифрованное сообщение: {encrypted_message}\")\nprint(f\"Расшифрованное сообщение: {message}\")",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "encrypted_message",
        "kind": 5,
        "importPath": "lab6.enigma",
        "description": "lab6.enigma",
        "peekOfCode": "encrypted_message = encrypt_message(message)\nprint(f\"Зашифрованное сообщение: {encrypted_message}\")\nprint(f\"Расшифрованное сообщение: {message}\")",
        "detail": "lab6.enigma",
        "documentation": {}
    },
    {
        "label": "split_into_blocks",
        "kind": 2,
        "importPath": "lab7.lab7",
        "description": "lab7.lab7",
        "peekOfCode": "def split_into_blocks(data, block_size):\n    # Вычисляем количество блоков, которые будут созданы\n    num_blocks = len(data) // block_size\n    # Определяем, нужно ли добавить дополнение\n    if len(data) % block_size != 0:\n        num_blocks += 1\n    # Создаем список для хранения блоков\n    blocks = []\n    # Разбиваем данные на блоки\n    for i in range(num_blocks):",
        "detail": "lab7.lab7",
        "documentation": {}
    },
    {
        "label": "generate_key",
        "kind": 2,
        "importPath": "lab7.lab7",
        "description": "lab7.lab7",
        "peekOfCode": "def generate_key(surname):\n    # Ensure the key length is suitable for Triple DES (either 16 or 24 bytes)\n    key = surname.encode('utf-8')\n    if len(key) < 16:\n        # Pad the key to 16 bytes if it's shorter\n        key = key.ljust(16, b'\\0')\n    elif len(key) > 24:\n        # Truncate the key to 24 bytes if it's longer\n        key = key[:24]\n    return key",
        "detail": "lab7.lab7",
        "documentation": {}
    },
    {
        "label": "encrypt",
        "kind": 2,
        "importPath": "lab7.lab7",
        "description": "lab7.lab7",
        "peekOfCode": "def encrypt(data, key):\n    cipher = DES3.new(key, DES3.MODE_ECB)\n    # Ensure the data is padded to the block size\n    padded_data = pad_data(data, cipher.block_size)\n    return cipher.encrypt(padded_data)\n# Расшифрование данных\ndef decrypt(data, key):\n    cipher = DES3.new(key, DES3.MODE_ECB)\n    return cipher.decrypt(data)\n# Замер времени выполнения операции",
        "detail": "lab7.lab7",
        "documentation": {}
    },
    {
        "label": "decrypt",
        "kind": 2,
        "importPath": "lab7.lab7",
        "description": "lab7.lab7",
        "peekOfCode": "def decrypt(data, key):\n    cipher = DES3.new(key, DES3.MODE_ECB)\n    return cipher.decrypt(data)\n# Замер времени выполнения операции\ndef measure_execution_time(func, *args):\n    start_time = time.time()\n    result = func(*args)\n    end_time = time.time()\n    return result, end_time - start_time\n# Функция для дополнения данных до кратного размера блока",
        "detail": "lab7.lab7",
        "documentation": {}
    },
    {
        "label": "measure_execution_time",
        "kind": 2,
        "importPath": "lab7.lab7",
        "description": "lab7.lab7",
        "peekOfCode": "def measure_execution_time(func, *args):\n    start_time = time.time()\n    result = func(*args)\n    end_time = time.time()\n    return result, end_time - start_time\n# Функция для дополнения данных до кратного размера блока\ndef pad_data(data, block_size):\n    padding_length = block_size - (len(data) % block_size)\n    padding = bytes([padding_length]) * padding_length\n    return data + padding",
        "detail": "lab7.lab7",
        "documentation": {}
    },
    {
        "label": "pad_data",
        "kind": 2,
        "importPath": "lab7.lab7",
        "description": "lab7.lab7",
        "peekOfCode": "def pad_data(data, block_size):\n    padding_length = block_size - (len(data) % block_size)\n    padding = bytes([padding_length]) * padding_length\n    return data + padding\n# Функция для анализа лавинного эффекта\ndef avalanche_analysis(original_word, encrypted_word):\n    # Реализация анализа лавинного эффекта\n    pass\n# Пример использования\nif __name__ == \"__main__\":",
        "detail": "lab7.lab7",
        "documentation": {}
    },
    {
        "label": "avalanche_analysis",
        "kind": 2,
        "importPath": "lab7.lab7",
        "description": "lab7.lab7",
        "peekOfCode": "def avalanche_analysis(original_word, encrypted_word):\n    # Реализация анализа лавинного эффекта\n    pass\n# Пример использования\nif __name__ == \"__main__\":\n    data = b\"pivo pit vkusno zhit\"  # Ваши данные\n    key = generate_key(\"MAKAROV\")  # Преобразуем вашу фамилию в ключ\n    encrypted_data, encryption_time = measure_execution_time(encrypt, data, key)  # Шифруем данные\n    decrypted_data, decryption_time = measure_execution_time(decrypt, encrypted_data, key)  # Расшифровываем данные\n    print(\"Original Data:\", data)",
        "detail": "lab7.lab7",
        "documentation": {}
    },
    {
        "label": "bbs",
        "kind": 2,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "def bbs(p, q, x0, n):\n    # Проверяем, что p и q удовлетворяют условиям Блюма\n    if p % 4 != 3 or q % 4 != 3:\n        raise ValueError(\"p и q должны быть простыми числами такими, что p ≡ q ≡ 3 (mod 4)\")\n    # Вычисляем N и начальное значение x\n    N = p * q\n    x = x0\n    # Генерируем псевдослучайную последовательность\n    result = []\n    for _ in range(n):",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "p = 17\nq = 23\nx0 = 19\n# Генерируем последовательность\nsequence = bbs(p, q, x0, 10)  # Генерация 10 битов\nprint(\"Generated sequence:\", sequence)\n# Выводим x1, x3, x7 и x10\nx1 = sequence[0]\nx3 = sequence[2]\nx7 = sequence[6]",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "q = 23\nx0 = 19\n# Генерируем последовательность\nsequence = bbs(p, q, x0, 10)  # Генерация 10 битов\nprint(\"Generated sequence:\", sequence)\n# Выводим x1, x3, x7 и x10\nx1 = sequence[0]\nx3 = sequence[2]\nx7 = sequence[6]\nx10 = sequence[9]",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "x0",
        "kind": 5,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "x0 = 19\n# Генерируем последовательность\nsequence = bbs(p, q, x0, 10)  # Генерация 10 битов\nprint(\"Generated sequence:\", sequence)\n# Выводим x1, x3, x7 и x10\nx1 = sequence[0]\nx3 = sequence[2]\nx7 = sequence[6]\nx10 = sequence[9]\nprint(\"x1:\", x1)",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "sequence",
        "kind": 5,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "sequence = bbs(p, q, x0, 10)  # Генерация 10 битов\nprint(\"Generated sequence:\", sequence)\n# Выводим x1, x3, x7 и x10\nx1 = sequence[0]\nx3 = sequence[2]\nx7 = sequence[6]\nx10 = sequence[9]\nprint(\"x1:\", x1)\nprint(\"x3:\", x3)\nprint(\"x7:\", x7)",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "x1",
        "kind": 5,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "x1 = sequence[0]\nx3 = sequence[2]\nx7 = sequence[6]\nx10 = sequence[9]\nprint(\"x1:\", x1)\nprint(\"x3:\", x3)\nprint(\"x7:\", x7)\nprint(\"x10:\", x10)",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "x3",
        "kind": 5,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "x3 = sequence[2]\nx7 = sequence[6]\nx10 = sequence[9]\nprint(\"x1:\", x1)\nprint(\"x3:\", x3)\nprint(\"x7:\", x7)\nprint(\"x10:\", x10)",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "x7",
        "kind": 5,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "x7 = sequence[6]\nx10 = sequence[9]\nprint(\"x1:\", x1)\nprint(\"x3:\", x3)\nprint(\"x7:\", x7)\nprint(\"x10:\", x10)",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "x10",
        "kind": 5,
        "importPath": "lab8.bbs",
        "description": "lab8.bbs",
        "peekOfCode": "x10 = sequence[9]\nprint(\"x1:\", x1)\nprint(\"x3:\", x3)\nprint(\"x7:\", x7)\nprint(\"x10:\", x10)",
        "detail": "lab8.bbs",
        "documentation": {}
    },
    {
        "label": "polynomial_generator",
        "kind": 2,
        "importPath": "lab8.psp",
        "description": "lab8.psp",
        "peekOfCode": "def polynomial_generator():\n    # Коэффициенты полинома\n    coefficients = [1, 0, 0, 1, 0, 0, 1]\n    # Находим наименьшее общее кратное степеней x в полиноме\n    lcm = 12\n    # Генерируем начальную последовательность\n    initial_sequence = [1, 1, 1, 0, 0, 0]\n    # Генерируем значения полинома, начиная с начальной последовательности\n    for x in range(lcm):\n        value = sum(coefficient * (x ** degree) for degree, coefficient in enumerate(coefficients))",
        "detail": "lab8.psp",
        "documentation": {}
    },
    {
        "label": "rc4_encrypt",
        "kind": 2,
        "importPath": "lab8.rc4",
        "description": "lab8.rc4",
        "peekOfCode": "def rc4_encrypt(key, plaintext):\n    cipher = ARC4.new(key)\n    return cipher.encrypt(plaintext)\n# Оценка скорости выполнения операций генерации ПСП\ndef evaluate_rc4_speed():\n    key = b'\\x14\\x15\\x16\\x17\\x3C\\x3D'\n    plaintext = b'Hello, world!'\n    start_time = time.time()\n    rc4_encrypt(key, plaintext)\n    end_time = time.time()",
        "detail": "lab8.rc4",
        "documentation": {}
    },
    {
        "label": "evaluate_rc4_speed",
        "kind": 2,
        "importPath": "lab8.rc4",
        "description": "lab8.rc4",
        "peekOfCode": "def evaluate_rc4_speed():\n    key = b'\\x14\\x15\\x16\\x17\\x3C\\x3D'\n    plaintext = b'Hello, world!'\n    start_time = time.time()\n    rc4_encrypt(key, plaintext)\n    end_time = time.time()\n    return end_time - start_time\n# Пример использования\nencryption_time = evaluate_rc4_speed()\nprint(\"Время выполнения операции генерации ПСП:\", encryption_time, \"секунд\")",
        "detail": "lab8.rc4",
        "documentation": {}
    },
    {
        "label": "encryption_time",
        "kind": 5,
        "importPath": "lab8.rc4",
        "description": "lab8.rc4",
        "peekOfCode": "encryption_time = evaluate_rc4_speed()\nprint(\"Время выполнения операции генерации ПСП:\", encryption_time, \"секунд\")",
        "detail": "lab8.rc4",
        "documentation": {}
    },
    {
        "label": "generate_RSA_keys",
        "kind": 2,
        "importPath": "lab8.rsa",
        "description": "lab8.rsa",
        "peekOfCode": "def generate_RSA_keys():\n    # Генерация случайного простого числа p и q\n    p = Crypto.Util.number.getPrime(256)\n    q = Crypto.Util.number.getPrime(256)\n    # Выбор открытой экспоненты e\n    e = 65537\n    # Вычисление модуля n\n    n = p * q\n    # Вычисление функции Эйлера\n    phi = (p - 1) * (q - 1)",
        "detail": "lab8.rsa",
        "documentation": {}
    },
    {
        "label": "key",
        "kind": 5,
        "importPath": "lab8.rsa",
        "description": "lab8.rsa",
        "peekOfCode": "key = generate_RSA_keys()\nprint(\"Открытый ключ (n, e):\", key.n, key.e)\nprint(\"Закрытый ключ (d):\", key.d)",
        "detail": "lab8.rsa",
        "documentation": {}
    },
    {
        "label": "generate_superincreasing_sequence",
        "kind": 2,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "def generate_superincreasing_sequence(z, length):\n    sequence = []\n    for i in range(length):\n        next_element = random.randint(1, 2**z - 1) + sum(sequence)\n        sequence.append(next_element)\n    return sequence\ndef generate_normal_sequence(superincreasing_sequence):\n    normal_sequence = []\n    for i in range(len(superincreasing_sequence)):\n        normal_sequence.append(superincreasing_sequence[i] * (i + 1))",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "generate_normal_sequence",
        "kind": 2,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "def generate_normal_sequence(superincreasing_sequence):\n    normal_sequence = []\n    for i in range(len(superincreasing_sequence)):\n        normal_sequence.append(superincreasing_sequence[i] * (i + 1))\n    return normal_sequence\ndef encode_message(message, encoding_type):\n    if encoding_type == \"Base64\":\n        encoded_message = base64.b64encode(message.encode()).decode()\n    elif encoding_type == \"ASCII\":\n        encoded_message = ''.join([str(ord(char)) for char in message])",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "encode_message",
        "kind": 2,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "def encode_message(message, encoding_type):\n    if encoding_type == \"Base64\":\n        encoded_message = base64.b64encode(message.encode()).decode()\n    elif encoding_type == \"ASCII\":\n        encoded_message = ''.join([str(ord(char)) for char in message])\n    return encoded_message\ndef decode_message(encoded_message, encoding_type):\n    if encoding_type == \"Base64\":\n        decoded_message = base64.b64decode(encoded_message).decode()\n    elif encoding_type == \"ASCII\":",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "decode_message",
        "kind": 2,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "def decode_message(encoded_message, encoding_type):\n    if encoding_type == \"Base64\":\n        decoded_message = base64.b64decode(encoded_message).decode()\n    elif encoding_type == \"ASCII\":\n        decoded_message = ''.join([chr(int(encoded_message[i:i+3])) for i in range(0, len(encoded_message), 3)])\n    return decoded_message\ndef measure_time(func, *args):\n    start_time = time.time()\n    result = func(*args)\n    end_time = time.time()",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "measure_time",
        "kind": 2,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "def measure_time(func, *args):\n    start_time = time.time()\n    result = func(*args)\n    end_time = time.time()\n    execution_time = end_time - start_time\n    return result, execution_time\n# Генерация сверхвозрастающей последовательности\nz = 6  # или 8 для ASCII\nsuperincreasing_sequence = generate_superincreasing_sequence(z, length=10)\n# Генерация нормальной последовательности",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "z = 6  # или 8 для ASCII\nsuperincreasing_sequence = generate_superincreasing_sequence(z, length=10)\n# Генерация нормальной последовательности\nnormal_sequence = generate_normal_sequence(superincreasing_sequence)\n# Шифрование сообщения\nmessage = \"Иванов Иван Иванович\"\nencoded_message_base64 = encode_message(message, \"Base64\")\nencoded_message_ascii = encode_message(message, \"ASCII\")\n# Расшифрование сообщения\ndecoded_message_base64 = decode_message(encoded_message_base64, \"Base64\")",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "superincreasing_sequence",
        "kind": 5,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "superincreasing_sequence = generate_superincreasing_sequence(z, length=10)\n# Генерация нормальной последовательности\nnormal_sequence = generate_normal_sequence(superincreasing_sequence)\n# Шифрование сообщения\nmessage = \"Иванов Иван Иванович\"\nencoded_message_base64 = encode_message(message, \"Base64\")\nencoded_message_ascii = encode_message(message, \"ASCII\")\n# Расшифрование сообщения\ndecoded_message_base64 = decode_message(encoded_message_base64, \"Base64\")\ndecoded_message_ascii = decode_message(encoded_message_ascii, \"ASCII\")",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "normal_sequence",
        "kind": 5,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "normal_sequence = generate_normal_sequence(superincreasing_sequence)\n# Шифрование сообщения\nmessage = \"Иванов Иван Иванович\"\nencoded_message_base64 = encode_message(message, \"Base64\")\nencoded_message_ascii = encode_message(message, \"ASCII\")\n# Расшифрование сообщения\ndecoded_message_base64 = decode_message(encoded_message_base64, \"Base64\")\ndecoded_message_ascii = decode_message(encoded_message_ascii, \"ASCII\")\n# Оценка времени выполнения операций\ndecoded_message, decoding_time = measure_time(decode_message, encoded_message_base64, \"Base64\")",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "message",
        "kind": 5,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "message = \"Иванов Иван Иванович\"\nencoded_message_base64 = encode_message(message, \"Base64\")\nencoded_message_ascii = encode_message(message, \"ASCII\")\n# Расшифрование сообщения\ndecoded_message_base64 = decode_message(encoded_message_base64, \"Base64\")\ndecoded_message_ascii = decode_message(encoded_message_ascii, \"ASCII\")\n# Оценка времени выполнения операций\ndecoded_message, decoding_time = measure_time(decode_message, encoded_message_base64, \"Base64\")\nencoded_message, encoding_time = measure_time(encode_message, message, \"Base64\")\nprint(\"Decoded message (Base64):\", decoded_message)",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "encoded_message_base64",
        "kind": 5,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "encoded_message_base64 = encode_message(message, \"Base64\")\nencoded_message_ascii = encode_message(message, \"ASCII\")\n# Расшифрование сообщения\ndecoded_message_base64 = decode_message(encoded_message_base64, \"Base64\")\ndecoded_message_ascii = decode_message(encoded_message_ascii, \"ASCII\")\n# Оценка времени выполнения операций\ndecoded_message, decoding_time = measure_time(decode_message, encoded_message_base64, \"Base64\")\nencoded_message, encoding_time = measure_time(encode_message, message, \"Base64\")\nprint(\"Decoded message (Base64):\", decoded_message)\nprint(\"Decoding time (Base64):\", decoding_time)",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "encoded_message_ascii",
        "kind": 5,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "encoded_message_ascii = encode_message(message, \"ASCII\")\n# Расшифрование сообщения\ndecoded_message_base64 = decode_message(encoded_message_base64, \"Base64\")\ndecoded_message_ascii = decode_message(encoded_message_ascii, \"ASCII\")\n# Оценка времени выполнения операций\ndecoded_message, decoding_time = measure_time(decode_message, encoded_message_base64, \"Base64\")\nencoded_message, encoding_time = measure_time(encode_message, message, \"Base64\")\nprint(\"Decoded message (Base64):\", decoded_message)\nprint(\"Decoding time (Base64):\", decoding_time)\nprint(\"Encoded message (Base64):\", encoded_message_base64)",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "decoded_message_base64",
        "kind": 5,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "decoded_message_base64 = decode_message(encoded_message_base64, \"Base64\")\ndecoded_message_ascii = decode_message(encoded_message_ascii, \"ASCII\")\n# Оценка времени выполнения операций\ndecoded_message, decoding_time = measure_time(decode_message, encoded_message_base64, \"Base64\")\nencoded_message, encoding_time = measure_time(encode_message, message, \"Base64\")\nprint(\"Decoded message (Base64):\", decoded_message)\nprint(\"Decoding time (Base64):\", decoding_time)\nprint(\"Encoded message (Base64):\", encoded_message_base64)\nprint(\"Encoding time (Base64):\", encoding_time)",
        "detail": "lab9.lab9",
        "documentation": {}
    },
    {
        "label": "decoded_message_ascii",
        "kind": 5,
        "importPath": "lab9.lab9",
        "description": "lab9.lab9",
        "peekOfCode": "decoded_message_ascii = decode_message(encoded_message_ascii, \"ASCII\")\n# Оценка времени выполнения операций\ndecoded_message, decoding_time = measure_time(decode_message, encoded_message_base64, \"Base64\")\nencoded_message, encoding_time = measure_time(encode_message, message, \"Base64\")\nprint(\"Decoded message (Base64):\", decoded_message)\nprint(\"Decoding time (Base64):\", decoding_time)\nprint(\"Encoded message (Base64):\", encoded_message_base64)\nprint(\"Encoding time (Base64):\", encoding_time)",
        "detail": "lab9.lab9",
        "documentation": {}
    }
]